# herding cats

================================================================================================
## SUM FUNCTION
================================================================================================
def sum(xs: List[Int]): Int = xs.foldLeft(0)( _ + _ )
sum: (xs: List[Int])Int

scala> sum(List(1,2,3))
res0: Int = 6

// Monoid
object IntMonoid {
     |          def mappend(a: Int, b: Int): Int = a + b
     |          def mzero: Int = 0
     |        }
defined object IntMonoid

scala>  def sum(xs: List[Int]): Int = xs.foldLeft(IntMonoid.mzero)(IntMonoid.mappend)
sum: (xs: List[Int])Int

scala> sum(List(1,2,3,4))
res1: Int = 10

// Parametric Monoid
scala> trait Monoid[A] {
     |          def mappend(a1: A, a2: A): A
     |          def mzero: A
     |        }
defined trait Monoid

scala> object IntMonoid extends Monoid[Int] {
     |          def mappend(a: Int, b: Int): Int = a + b
     |          def mzero: Int = 0
     |        }
defined object IntMonoid

scala> def sum(xs: List[Int], m: Monoid[Int]): Int = xs.foldLeft(m.mzero)(m.mappend)
sum: (xs: List[Int], m: Monoid[Int])Int

scala> sum(List(1, 2, 3, 4), IntMonoid)
res2: Int = 10

// IMPLICIT Monoid
scala> def sum[A](xs: List[A])(implicit m: Monoid[A]): A = xs.fold(m.mzero)(m.mappend)
sum: [A](xs: List[A])(implicit m: Monoid[A])A

scala> sum(List(1,2,3,4))
          ^
       error: could not find implicit value for parameter m: Monoid[Int]

scala> implicit val intMonoid = IntMonoid
intMonoid: IntMonoid.type = IntMonoid$@145a821d

scala> sum(List(1,2,3,4))
res5: Int = 10

scala> def sum[A: Monoid](xs: List[A]): A = {
     |          val m = implicitly[Monoid[A]]
     |          xs.foldLeft(m.mzero)(m.mappend)
     |        }
sum: [A](xs: List[A])(implicit evidence$1: Monoid[A])A

scala> sum(List(1,2,3,4))
res6: Int = 10

SUMMARY: =======================================================================================
trait Monoid[A] {
  def mappend(a1: A, a2: A): A
  def mzero: A
}
object Monoid {
  implicit val IntMonoid: Monoid[Int] = new Monoid[Int] {
    def mappend(a: Int, b: Int): Int = a + b
    def mzero: Int = 0
  }
  implicit val StringMonoid: Monoid[String] = new Monoid[String] {
    def mappend(a: String, b: String): String = a + b
    def mzero: String = ""
  }
}
def sum[A: Monoid](xs: List[A]): A = {
  val m = implicitly[Monoid[A]]
  xs.foldLeft(m.mzero)(m.mappend)
}
================================================================================================

================================================================================================
## FUNCTOR apply/unit + map/fmap

IDENTITY:  Functor[X].map(identity) == Functor[X]
ASSOC: Functor[X].map(f).map(g) == Functor[X].map(x => g(f(x))
================================================================================================
scala> case class Bag[A](content: A) {
     |  def map[B](f: A => B): Bag[B] = Bag(f(content))
     | }
defined class Bag

scala> case class Sugar(weight: Double)
defined class Sugar

scala> val halfSugar = (sugar: Sugar) => Sugar(sugar.weight / 2)
halfSugar: Sugar => Sugar = $$Lambda$1386/1684336663@755a90a6

scala> val sugarBag = (sugar: Sugar) => Bag(sugar)
sugarBag: Sugar => Bag[Sugar] = $$Lambda$1387/596453359@91c11b6

scala> val halfSugarBag = (sugar: Sugar) => sugarBag(sugar).map(halfSugar)
halfSugarBag: Sugar => Bag[Sugar] = $$Lambda$1388/186764223@578ac0be

scala> halfSugarBag(Sugar(1))
res7: Bag[Sugar] = Bag(Sugar(0.5))

================================================================================================
================================================================================================
## MONAD = Functor + flatten / flatMap(map andThen flatten)

LEFT  IDENTITY:  unit(x).flatMap(f) == f(x)
RIGHT IDENTITY: 
================================================================================================
case class Bag[A](content: A) {
  def map[B](f: A => B): Bag[B] = Bag(f(content))

  def flatMap[B](f: A => Bag[B]): Bag[B] = f(content)

  def flatten = content
}
val double = (s: Sugar) => Bag(Sugar(s.weight * 2))

LEFT IDENTITY:  
	Bag(Sugar(1)).flatMap(double) == double(Sugar(1))
	res11: Boolean = true
RIGHT IDENTITY: 
	Bag(Sugar(1)).flatMap(Bag.apply) == Bag(Sugar(1))
	res14: Boolean = true


